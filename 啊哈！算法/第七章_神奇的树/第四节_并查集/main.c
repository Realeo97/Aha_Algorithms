/*
并查集算法：并查集通过一个一维数组来实现，其本质是维护一个森林。
刚开始的时候，森林的每个点都是孤立的，也可以理解为每个点就是一棵只有一个点的树，之后
通过一些条件，逐渐将这些树合并成一棵大树。
*/
#include "stdio.h"
int f[1001] = {0},n,m,sum = 0;
//这里是初始化，非常的重要，数组里存的是自己的数组下标的编号就好了
void init()
{
	int i;
	for(i = 1;i <= n;i++)
	{
		f[i] = i;
	}
	return;
}
//这是找爹的递归函数，不停地去找爹，知道找到祖宗为止，其实就是找犯罪团伙的最高领导人，擒贼先擒王的原则
int getf(int v)
{
	if(f[v] == v)
	{
		return v;
	}
	else
	{
		//这里是路径压缩，每次在函数返回的时候，顺带把路上遇到的人的BOOS改为最后找到的祖宗的编号，
		//也就是犯罪团伙最高领导人编号。这样可以提高今后找到犯罪团伙的最高领导人(其实就是树的祖先)的速度。
		f[v] = getf(f[v]);//这里进行了路径压缩
		return f[v];
	}
}

//这里是合并了两个子集合的函数
void merge(int v,int u)
{
	int t1,t2;//t1,t2分别为v和u的大BOSS(首领)，每次双方的会谈都必须是各自最高领导人才行
	t1 = getf(v);
	t2 = getf(u);
	if(t1 != t2)//判断两个节点是否在同一个集合中，即是否为同一个祖先
	{
		f[t2] = t1;//靠左原则，左边变成右边的BOSS。即把右边的集合，作为左边集合的子集合
	}
	return;
}

//请从此处开始阅读程序，从主函数开始阅读程序是一个好习惯
int main()
{
	int i,x,y;
	scanf("%d %d",&n,&m);

	init();//初始化是必须得
	for(i = 1;i <= m;i++)
	{
		//开始合并犯罪团伙
		scanf("%d %d",&x,&y);
		merge(x,y);
	}

	//最后扫描有多少个独立的犯罪团伙
	for(i = 1;i <= n;i++)
	{
		if(f[i] == i)
		{
			sum++;
		}
	}
	printf("%d\n",sum );
	getchar();getchar();
	return 0;
}
/*
示例输入：
11 10         //第一行n，m，n表示强盗的人数，m表示警方收到的m条线索。
1 2           //接下来m行每一行有两个数a和b，表示强盗a和强盗b是同伙。
3 4
5 2
4 6
2 6
7 11
8 7
9 7
9 11
1 6
示例输出：
3
*/