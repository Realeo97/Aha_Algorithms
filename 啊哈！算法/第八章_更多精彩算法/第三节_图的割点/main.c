/*
在一个无向连通图中，如果删除某个顶点后，图不再连通(即任意两点之间不能相互到达),
我们称这样的顶点为割点(或称为割顶)。
如果k点是割点，那么剩下的没有被访问过的点至少会有一个点在不经过k点的情况下，是
无论如何再也回不到已访问过的点了。那么一个连通图就被割点分割成多个不连通的子图了
当深度优先遍历访问到顶点u时，假设图中还有顶点v是没有访问过的点，如何判断顶点v在不经过顶点u
的情况下是否能回到之前访问过的任意一个点：如何检测顶点v不经过父顶点u的情况下还能否回到祖先
我们需要一个数组low来记录每个顶点在不经过父顶点时，能够回到的最小时间戳。
对于某个顶点u，如果存在至少一个顶点v(即顶点u的儿子)，使得low[v] >= num[u],即不能回到祖先，那么u点为割点
实际应用中需要改为邻接表来存储图，时间复杂度为O(N + M),否则时间复杂度为O(N2)
*/
#include "stdio.h"
int n,m,e[9][9],root;
int num[9],low[9],flag[9],index;//index用来进行时间戳的递增
//求两个数中比较小的一个数的函数
int min(int a,int b)
{
	return a < b? a : b;
}
//割点算法核心
void dfs(int cur,int father)//需要传入两个参数，当前顶点编号和父顶点编号
{
	int child = 0,i;//child用来记录在生成树中当前顶点cur的儿子个数

	index++;//时间戳加1
	num[cur] = index;//当前顶点cur的时间戳
	low[cur] = index;//当前顶点cur能够访问到最早顶点的时间戳，刚开始当然是自己啦
	for(i = 1;i <= n;i++)//枚举当前顶点cur有边相连的顶点
	{
		if(e[cur][i] == 1)
		{
			if(num[i] == 0)//如果顶点i的时间戳为0，说明顶点i还没有被访问过
			{
				//从生成树角度来说，此时i为cur的儿子
				child++;
				dfs(i,cur);//继续往下深度优先遍历
				//更新当前顶点cur能访问到最早顶点的时间戳
				low[cur] = min(low[cur],low[i]);
				//如果当前顶点不是根节点并且满足low[i] >= num[cur],则当前顶点为割点
				if(cur != root && low[i] >= num[cur])
				{
					flag[cur] = 1;
				}
				//如果当前顶点是根节点，在生成树中根节点必须要有两个儿子，那个这个根节点才是割点
				if(cur== root && child == 2)
				{
					flag[cur] = 1;
				}
			}
			else if(i != father)
				//否则如果顶点i曾被访问过，并且这个顶点不是当前顶点cur的父亲，则说明
				//此时的i为cur的祖先，因此需要更新当前节点cur能访问到最早顶点的时间戳
			{
				low[cur] = min(low[cur],num[i]);
			}
		}
	}
	return;
}

int main()
{
	int i,j,x,y;
	scanf("%d %d",&n,&m);
	for(i = 1;i <= n;i++)
	{
		for(j = 1;j <= n;j++)
		{
			e[i][j] = 0;
		}
	}

	for(i = 1;i <= m;i++)
	{
		scanf("%d %d",&x,&y);
		e[x][y] = 1;
		e[y][x] = 1;
	}
	root = 1;
	dfs(1,root);//从一号顶点开始进行深度优先遍历

	for(i = 1;i <= n;i++)
	{
		if(flag[i] == 1)
		{
			printf("%d\n",i );
		}
	}
	getchar();getchar();
	return 0;
}
/*
示例输入：
6 7				//第一行两个数n和m，n表示有n个顶点，m表示有m条边
1 4				//接下来m行，每行形如“a b“表示顶点a和顶点b之间有边
1 3
4 2
3 2
2 5
2 6
5 6
示例输出：
2
*/