/*想知道地图中有多少个独立的小岛，并对不同独立小岛染色
从(1,1)开始枚举，一直枚举到(n,m)
*/
#include "stdio.h"
int a[51][51],book[51][51];
int n,m,sum;
void dfs(int x,int y,int color)
{

	//定义一个表示走的方向的数组
	int next[4][2] = {{0,1},{1,0},{0,-1},{-1,0}};//分别表示向右，向下，向左，向上走
	int k,tx,ty;

	a[x][y] = color;//对a[x][y]这个格子进行染色
	//枚举四个方向
	for(k = 0;k <= 3;k++)
	{
		//下一步的坐标
		tx = x + next[k][0];
		ty = y + next[k][1];
		//判断是否是边界
		if(tx < 1 || tx > n || ty < 1 || ty > m)
		{
			continue;
		}
		//判断是否为陆地或已经走过
		if(a[tx][ty] > 0 && book[tx][ty] == 0)
		{
			sum++;
			book[tx][ty] = 1;//标记这个点已经走过
			dfs(tx,ty,color);//开始尝试下一个点
		}
	}
	return;
}

int main()
{
	int i,j,num = 0;
	scanf("%d %d",&n,&m);
	//读入地图
	for(i = 1;i <= n;i++)
	{
		for(j = 1;j <= m;j++)
		{
			scanf("%d",&a[i][j]);
		}
	}

	//对每个大于0的点尝试进行dfs染色
	for(i = 1;i <= n;i++)
	{
		for(j = 1;j <= m;j++)
		{
			if(a[i][j] > 0)
			{
				num--;//小岛需要染的染色编号，每发现一个小岛应染不同的染色，因此每次都要减1
				book[i][j] = 1;
				dfs(i,j,num);
			}
		}
	}

	//输出已经染色后的地图
	for(i = 1;i <= n;i++)
	{
		for(j = 1;j <= m;j++)
		{
			printf("%3d",a[i][j] );//%d中的3是c语言中的场宽
		}
		printf("\n");
	}
	//输出小岛的个数
	printf("有%d个小岛\n",-num );
	getchar();getchar();
	return 0 ;
}
/*
示例输入：
10 10
1 2 1 0 0 0 0 0 2 3
3 0 2 0 1 2 1 0 1 2
4 0 1 0 1 2 3 2 0 1
3 2 0 0 0 1 2 4 0 0 
0 0 0 0 0 0 1 5 3 0
0 1 2 1 0 1 5 4 3 0
0 1 2 3 1 3 6 2 1 0
0 0 3 4 8 9 7 5 0 0
0 0 0 3 7 8 6 0 1 2
0 0 0 0 0 0 0 0 1 0
示例输出：
-1  -1  -1   0   0   0   0   0  -2  -2
-1   0  -1   0  -3  -3  -3   0  -2  -2
-1   0  -1   0  -3  -3  -3  -3   0  -2
-1  -1   0   0   0  -3  -3  -3   0   0
 0   0   0   0   0   0  -3  -3  -3   0
 0  -3  -3  -3   0  -3  -3  -3  -3   0
 0  -3  -3  -3  -3  -3  -3  -3  -3   0
 0   0  -3  -3  -3  -3  -3  -3   0   0
 0   0   0  -3  -3  -3  -3   0  -4  -4
 0   0   0   0   0   0   0   0  -4   0
 有4个小岛 
*/