/*使用深度优先搜索解决数的全排列问题*/
/*
深度优先搜索的基本模型：
void dfs(int step)
{
	判断边界
	尝试每一种可能 for(i = 1;i <= n;i++)
	{
	继续下一步 dfs(step + 1);
	}
	返回
}
*/

#include "stdio.h"
int a[10],book[10],n;//此处特别说明一下：C语言的全局变量在没有赋值以前默认为0，因此这里的book数组无需全部再次赋初值0

void dfs(int step)//step表示现在站在第几个盒子面前
{
	int i;
	if(step == n + 1)//如果站在第n+1个盒子面前。则表示前n个盒子已经放好扑克牌
	{
		//输出一种排列(1~n号盒子中的扑克牌编号)
		for(i = 1;i <= n;i++)
		{
			printf("%d",a[i] );
		}
		printf("\n");
		return;//返回之前的一步(最近一次调用dfs函数的地方)
	}

	//此时站在step个盒子面前，应该放那张牌呢？
	//按照1,2,3。。。n的顺序一一尝试
	for(i = 1;i <= n;i++)
	{
		//判断扑克牌i是否还在手上
		if(book[i] == 0)//book[i] == 0表示i号扑克牌还在手上
		{
			//开始尝试使用扑克牌i
			a[step] = i;//将i号扑克牌放入step号盒子中
			book[i] = 1;//将book[i]设置为1，表示i号扑克牌已不再手中

			//将step个盒子已经放好扑克牌，接下来需走到下个盒子面前
			dfs(step + 1);//这里通过函数的递归调用来实现(自己调用自己)
			book[i] = 0;//这是非常重要的一步，一定要将刚才尝试的扑克牌收回，才能进行下一次尝试
		}
	}
	return;
}

int main()
{
	scanf("%d",&n);//输入时要注意n为1~9的整数
	dfs(1);//首先站在1号小盒子面前
	getchar();getchar();
	return 0;
}
/*
示例输入：
3
示例输出：
123
132
213
312
321
*/