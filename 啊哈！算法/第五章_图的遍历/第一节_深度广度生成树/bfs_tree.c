/*
广度优先遍历的主要思想：
首先以一个未被访问过的顶点作为起始顶点，访问其所有相邻的顶点，然后对每个相邻的顶点，再访问
它们相邻未被访问过的顶点，直到所有顶点都被访问过，遍历结束。
图的邻接矩阵存储法：
利用一个二维数组来存储，第i行第j列表示的就是顶点i到顶点j是否有边。1表示有边，∞表示没有边，将自己到自己设为0.
变量的作用：
cur存储的是当前正在遍历的顶点，二维数组e存储的就是图的边(邻接矩阵)，数组book用来记录哪些顶点已经访问过，
变量sum用来记录已经访问过多少个顶点，变量n存储的是图的顶点的总个数。
*/
#include "stdio.h"
int main()
{
	int i,j,n,m,a,b,cur,book[101] = {0},e[101][101];
	int que[1001],head,tail;
	scanf("%d %d",&n,&m);
	//初始化二维矩阵
	for(i = 1;i <= n;i++)
	{
		for(j = 1;j <= n;j++)
		{
			if(i == j)
			{
				e[i][j] = 0;
			}
			else
			{
				e[i][j] = 99999999;//我们这里假设99999999为正无穷大
			}
		}
	}

	//读入顶点之前的边
	for(i = 1;i <= m;i++)
	{
		scanf("%d %d",&a,&b);
		e[a][b] = 1;
		e[b][a] = 1;//这里是无向图，所以e[b][a]也要赋值为1
	}

	//队列初始化
	head = 1;
	tail = 1;

	//从1号顶点出发，将1号顶点加入队列
	que[tail] = 1;
	tail++;
	book[1] = 1;//标记1号顶点已访问

	//当队列不为空时循环
	while(head < tail && tail <= n)
	{
		cur = que[head];//当前正在访问的顶点编号
		for(i = 1;i <= n;i++)//从1~n依次尝试
		{
			//判断从顶点cur到顶点i是否有边，并判断顶点i是否已经访问过
 			if(e[cur][i] == 1 && book[i] == 0)
			{
				//如果顶点cur到点i有边，并且i没有被访问过，则将顶点i入队
				que[tail] = i;
				tail++;
				book[i] = 1;//标记顶点i已被访问过
			}
			//如果tail大于n，则表明所有顶点都已被访问过
			if(tail > n)
			{
				break;
			}
		}
		head++;//注意这个地方，前往不要忘记一个顶点扩展结束后，head++,然后才能继续往下扩展
	}
	for(i = 1;i < tail;i++)
	{
		printf("%d ",que[i] );
	}
	getchar();getchar();
	return 0;
}
/*
示例输入：
5 5
1 2
1 3
1 5
2 4
3 5
示例输出：
1 2 3 5 4
*/