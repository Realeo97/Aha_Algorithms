/*
深度优先遍历的主要思想：
首先以一个未被访问过的顶点作为起始点，沿着当前顶点的边走到未被访问过的顶点，当没有访问过的顶点时，
则返回上一个顶点，继续试探访问其他顶点，直到所有顶点都被访问过。显然，深度优先遍历是沿着图的某一
条分支遍历直到末端，然后回溯，再沿着另一条进行同样的遍历，直到所有的顶点都被访问过为止。
图的邻接矩阵存储法：
利用一个二维数组来存储，第i行第j列表示的就是顶点i到顶点j是否有边。1表示有边，∞表示没有边，将自己到自己设为0.
变量的作用：
cur存储的是当前正在遍历的顶点，二维数组e存储的就是图的边(邻接矩阵)，数组book用来记录哪些顶点已经访问过，
变量sum用来记录已经访问过多少个顶点，变量n存储的是图的顶点的总个数。
*/
#include "stdio.h"
int book[101],sum,n,e[101][101];
void dfs(int cur)//cur是当前所在点的编号
{
	int i;
	printf("%2d", cur);
	sum++;//每访问一个点，sum就加1
	if(sum == n)
	{
		return;//所有的顶点都已经访问过则直接退出
	}
	for(i = 1; i <= n; i++)//从1号顶点到n号顶点依次尝试，看哪些顶点与当前顶点cur有边相连
	{
		//判断当前顶点cur到顶点i是否有边，并且判断顶点i是否已经访问过
		if(e[cur][i] == 1 && book[i] == 0)
		{
			book[i] = 1;//标记顶点i已经被访问过
			dfs(i);//从顶点i再出发继续遍历
		}
	}
	return;
}

int main()
{
	int i,j,m,a,b;
	scanf("%d %d",&n,&m);
	//初始化二维矩阵
	for(i = 1;i <= n;i++)
	{
		for(j = 1;j <= n;j++)
		{
			if(i == j)
			{
				e[i][j] = 0;
			}
			else
			{
				e[i][j] = 99999999;//我们这里假设99999999为正无穷大
			}
		}
	}

	//读入顶点之前的边
	for(i = 1;i <= m;i++)
	{
		scanf("%d %d",&a,&b);
		e[a][b] = 1;
		e[b][a] = 1;//这里是无向图，所以e[b][a]也要赋值为1
	}

	//从1号顶点出发
	book[1] = 1;//标记1号顶点已访问
	dfs(1);//从一号顶点开始遍历

	getchar();getchar();
	return 0;
}
/*
示例输入：
5 5
1 2
1 3
1 5
2 4
3 5
示例输出：
1 2 4 3 5
*/